use std::path::PathBuf;

use anyhow::Result;
use nova_scotia::{
    circom::{circuit::CircomCircuit, reader::{load_r1cs, load_witness_from_file}},
    create_public_params, FileLocation, F, C1, C2,
};
use nova_snark::{
    provider,
    PublicParams, RecursiveSNARK,
};
use ff::Field;

fn main() -> Result<()> {
    // Define the cycle of curves compatible with Circom's bn254 prime
    type G1 = provider::bn256_grumpkin::bn256::Point;
    type G2 = provider::bn256_grumpkin::grumpkin::Point;

    // Determine paths to the R1CS and witness files
    let mut args = std::env::args().skip(1);
    let r1cs_path: PathBuf = args
        .next()
        .map(PathBuf::from)
        .unwrap_or_else(|| PathBuf::from("build/cred-bind.r1cs"));
    let witness_path: PathBuf = args
        .next()
        .map(PathBuf::from)
        .unwrap_or_else(|| PathBuf::from("build/cred-bind.wtns"));

    // Load circuit and witness generated by Circom
    let r1cs = load_r1cs::<G1, G2>(&FileLocation::PathBuf(r1cs_path));
    let witness = load_witness_from_file::<F<G1>>(&witness_path);

    // Create the Nova public parameters
    let pp: PublicParams<G1, G2, C1<G1>, C2<G2>> = create_public_params(r1cs.clone());

    // Extract the initial public inputs from the witness (first half of public wires)
    let arity = (r1cs.num_inputs - 1) / 2;
    let start_public_input = witness[1..=arity].to_vec();

    // Prepare primary and secondary circuits
    let circuit_primary = CircomCircuit {
        r1cs: r1cs.clone(),
        witness: Some(witness),
    };
    let circuit_secondary = nova_scotia::C2::<G2>::default();
    let z0_secondary = vec![<G2 as nova_snark::traits::Group>::Scalar::ZERO];

    // Construct and prove the base step
    let mut recursive_snark = RecursiveSNARK::new(
        &pp,
        &circuit_primary,
        &circuit_secondary,
        start_public_input.clone(),
        z0_secondary.clone(),
    );
    recursive_snark.prove_step(
        &pp,
        &circuit_primary,
        &circuit_secondary,
        start_public_input.clone(),
        z0_secondary.clone(),
    )?;

    // Verify the resulting proof of step 0
    let res = recursive_snark.verify(&pp, 1, &start_public_input, &z0_secondary)?;
    println!("Recursive proof verified: {:?}", res);

    Ok(())
}
